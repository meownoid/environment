#!/usr/bin/env python3

"""CLI for transcoding videos into an Apple-friendly H.264 MP4.

Example:
    transcode input.mov --resolution 4k --force output.mp4
"""

import argparse
import sys
import os
import subprocess
import tempfile

HEIGHTS = {
    "2160": 2160,
    "1440": 1440,
    "1080": 1080,
    "720": 720,
    "4k": 2160,
    "2k": 1440,
}


def transcode_for_apple(
    input_path: str, output_path: str, height: int, threads: int | None = None
) -> bool:
    # This is the ffmpeg command.
    # -i: input file
    # -c:v libx264: Use the H.264 video codec, which is widely supported.
    # -c:a aac: Use AAC for Apple compatibility.
    # -b:a 320k: Request the highest practical AAC bitrate for high quality output.
    # -profile:a aac_low: Use the AAC-LC profile for broad device support.
    # -vf scale=-2:<height>: Force the requested output height while keeping the aspect ratio.
    # -pix_fmt yuv420p: Sets the pixel format for broad compatibility.
    # -movflags +faststart: Moves metadata to the start of the file,
    #                       which helps the video start playing faster when streamed.
    # -y: Overwrite output file if it exists (though we check for this already).
    command = [
        "ffmpeg",
        "-i",
        input_path,
        "-c:v",
        "libx264",
        "-c:a",
        "aac",
        "-b:a",
        "320k",
        "-profile:a",
        "aac_low",
        "-vf",
        f"scale=-2:{height}",
        "-pix_fmt",
        "yuv420p",
        "-movflags",
        "+faststart",
        "-y",
    ]

    if threads is not None:
        command.extend(["-threads", str(threads)])

    command.append(output_path)

    try:
        subprocess.run(command, check=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error during transcoding '{input_path}':")
        if e.stderr:
            try:
                print(e.stderr.decode())
            except AttributeError:
                print(e.stderr)
        return False
    except FileNotFoundError:
        print("Error: 'ffmpeg' command not found.")
        print("Please make sure ffmpeg is installed and in your system's PATH.")
        return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Transcode a video for Apple devices.")
    parser.add_argument("input_path", help="Path to the source video file")
    parser.add_argument(
        "output_path",
        nargs="?",
        help="Optional output file path (defaults to <input_basename>.mp4)",
    )
    parser.add_argument(
        "-r",
        "--resolution",
        choices=tuple(HEIGHTS.keys()),
        default="1080",
        help="Output resolution (default: 1080)",
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Overwrite the output file if it already exists",
    )
    parser.add_argument(
        "-t",
        "--threads",
        type=int,
        help="Number of threads to use for transcoding (default: ffmpeg decides)",
    )

    args = parser.parse_args()

    input_file = args.input_path

    # Check if the input file exists.
    if not os.path.exists(input_file):
        print(f"Error: '{input_file}' not found")
        sys.exit(1)

    # Determine the output file path.
    output_file = args.output_path
    if output_file is None:
        base_name = os.path.splitext(os.path.basename(input_file))[0]
        output_file = f"{base_name}.mp4"

    if os.path.exists(output_file):
        if args.force:
            print(f"Output file '{output_file}' exists and will be overwritten.")
        else:
            print(f"Output file '{output_file}' already exists. Skipping.")
            sys.exit(1)

    if args.threads is not None and args.threads <= 0:
        print("Error: '--threads' must be a positive integer.")
        sys.exit(1)

    print(f"Transcoding '{input_file}'...")

    input_abs = os.path.abspath(input_file)
    output_abs = os.path.abspath(output_file)

    height = HEIGHTS[args.resolution]

    if input_abs == output_abs:
        with tempfile.TemporaryDirectory() as tmp_dir:
            temp_output = os.path.join(tmp_dir, os.path.basename(output_file))
            success = transcode_for_apple(
                input_file,
                temp_output,
                height,
                threads=args.threads,
            )
            if not success:
                sys.exit(1)
            os.replace(temp_output, output_file)
    else:
        success = transcode_for_apple(
            input_file,
            output_file,
            height,
            threads=args.threads,
        )
        if not success:
            sys.exit(1)

    print(f"Successfully transcoded to '{output_file}'")
